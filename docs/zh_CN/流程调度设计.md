

## 4.1 流程调度

工作流调度分为定时调度和手动调度。


### 4.1.1 流程状态

流程在运行的过程中有两种状态类型，**运行状态**用于表示该流程在运行过程中的状态，还有一个**容错状态**用来表示该流程因为挂服务出现的容错情况。

#### 运行状态

1. 正在运行
2. 准备暂停
    
    流程暂停功能并不能暂停正在执行的任务，设计上在当前正在执行的任务运行完成之后不再调度下一个任务，直接把下一个任务的状态改为暂停。
    
    子流程节点比较特别，子流程节点的暂停状态就是子流程的暂停状态，所以可以在子流程节点本身暂停，而不需要等待子流程节点运行完成。

3. 暂停

    当流程的状态为“准备暂停”并且该工作流的waitQueue和runningList都为空之后，将该流程状态改为“暂停”。

4. 准备停止

    同暂停一样，停止功能也不是直接停止正在执行的任务，设计上在当前正在执行的任务运行完成之后不再调度下一个任务。

5. 停止

    当流程的状态为“准备停止”并且该工作流的waitQueue和runningList都为空之后，将该流程状态改为“停止”。注意，暂停的流程还能“恢复”，但停止的流程不能恢复，只能从重运行一个流程实例。

6. 失败
7. 成功

#### 容错状态

容错状态是一个int型标识字段叫recovery，0代表正常，1代表正在容错

### 4.1.2 定时调度

定时调度由分布式的Quartz来完成，Quartz通过相关源数据库的锁机制，保证了同一个工作流不会被多个master节点同时调度。具体的流程的原理请参考https://tech.meituan.com/mt-crm-quartz.html

### 4.1.3 基于命令的调度

基于命令command的调度是指

1、用户通过前端页面点击**启动流程**，或**从该节点运行**、**从失败的节点运行**和**恢复暂停流程**四个操作命令来启动的流程。

2、由于系统容错生成的**恢复容错流程**命令来启动流程。

**注意：作为子流程被调起的流程实例不允许单独进行前端调度，在前端只能“查看”，不能进行“从该节点运行”，“从失败节点运行”，“暂停”，“恢复暂停流程”等操作，这些操作只能由父流程实例发起。**

**实现方式**

1. 接口调用方式

    由**escheduler-server**直接访问**escheduler-master**服务，调用**workflow-scheduler**启动流程实例。
    
    这种方式是一个同步执行的方式，用户发起启动流程的指令后，需要先从所有的escheduler-master节点中找到一个合适的节点，然后通过rest api或rpc调用访问该master节点，调用**workflow-scheduler**启动流程实例。
    
    **该方案优点：**
    
    1、同步调用
    2、同时只可能有一个master获取启动流程的调用指令，不需要所有节点通过锁去竞争。

    
    **缺点**
    
    1、escheduler-control与master节点之间有耦合两个服务之前有调用，master服务有状态。
    2、需要开发工具来判断escheduler-control与哪个escheduler-master通讯。
    3、当调用的master在调用过程中挂掉时，escheduler-control会有明显感知，前端UI报错。

2. 数据库扫描方式

    前端**UI**发出启动流程指令，**escheduler-server**往**mysql**中插入一条数据。所有**escheduler-master**服务都有一个后台线程一直定时扫描该mysql表，当发现有数据时，通过锁竞争该流程，竞争成功者负责流程实例的启动。
    
    这种方式是一种异步的执行方式，**escheduler-server**与**escheduler-master**之间只通过**mysql**交互，减少服务之前的依赖。同时不会因为**escheduler-master**服务是否正常让前端**UI**感知到。最典弄的场景是当所有master节点都挂掉时，前端用户依然可以手动启动流程，这时流程状态会一条显示为等待执行，等后台有任何**escheduler-master**启动后都会从Mysql中读取到该条启动请求，并实例化该流程，前端**UI**将看到流程状态变更为正在执行。
    
    **该方案优点：**
    
    1、容错性强，用户无感知。
    
    2、服务之前耦合程度低。
    
    3、mysql实际充当了一个缓冲队列，减小了系统负载。
    
    **缺点**
    
    1、需要使用分布式锁。系统其它模块有必须使用分布式锁的地方，所以我认为这里多一个也无所谓。
    
    2、流程的启动有延迟。但我们认为，在工作流系统中，流程的运行时长一般较长，秒级的延迟影响不大，只要前端给出当前的流程状态即可。

**这里我们选择第2种方式，手动调度业务流程图（我们叫它workflow 调度线程）：**

![PNG](docs/zh_CN/images/scanner.png)


### 4.1.4 各Command的区别

* **启动流程**

    启动流程是找到开始节点，放入workflow的waitQueue中开启执行。这个操作会新创建一个流程实例，无法在已经运行的流程实例上发起。
    
* **从该节点开始执行**

    找到指定的节点，然后放入workflow的waitQueue中开启执行。这个操作会新创建一个流程实例，无法在已经运行的流程实例上发起。
    
* **从失败节点开始执行**

    找到所有的失败节点，然后放入workflow的waitQueue中开启执行。这个操作会读取该失败的流程实例，只能在已经存在的流程实例上发起。
        
* **恢复暂停流程**

    找到所有暂停的节点，然后放入workflow的waitQueue中开启执行。这个操作会读取该暂停流程实例，只能在已经存在的流程实例上发起。
    
* **恢复容错流程**

    从开始节点开始，遍历整个图，找到所有该执行的节点（比如一个分支上的最后一个成功节点连线后面的未运行的节点，运行过但失败的节点），然后放入workflow的waitQueue中开启执行。这个操作由系统自动容错时发起，无法人为发起。



